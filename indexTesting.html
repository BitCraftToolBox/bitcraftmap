<!DOCTYPE html>
<html>
	<head>
		<title>Bitcraft Game Map</title>
    <link rel="icon" type="image/x-icon" href="assets/icons/MapCompass.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
		<link rel="stylesheet" href="assets/search/leaflet-search.src.css" crossorigin=""/>

		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js" crossorigin=""></script>
		<script src="assets/search/leaflet-search.src.js" crossorigin=""></script>
    <script src="assets/images/manifest.js"></script>

		<style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
			#map {
				height: 100vh;
				width: 100%;
        background-color: #2a3145;
			}
      #coords {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 5px 10px;
        z-index: 1000;
        font-family: monospace;
        border-radius:.25em;
      }
      .leaflet-tile,
      .leaflet-image-layer,
      .pixelated {
        image-rendering: pixelated;      /* most browsers */
        image-rendering: crisp-edges;    /* fallback */
        -ms-interpolation-mode: nearest-neighbor; /* old IE */
      }
    </style>
	</head>

	<body>
    <div id="map"></div>
		<div id="coords"></div>
    <script>

			const imageWidth = 2400;
			const imageHeight = 2400;
      const bitcraftWidth = 23040;  
      const bitcraftHeight = 23040 * 1.1547005;

      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -6,
        maxZoom: 6,
        zoomSnap: 0.1,
        attributionControl: false, // Remove watermark
        zoomControl: false, // Remove the zoom control top left
        preferCanvas: true,
        boxZoom: false
      });

      const mapBounds = [[0, 0], [bitcraftHeight, bitcraftWidth]];
      L.imageOverlay('assets/maps/map.png', mapBounds).addTo(map);

      //               N                     E
      //              lat                   lgt
      //           locationZ             locationX
      //         bottom to top         left to right
      //               v                     v
      map.setView([bitcraftHeight/2, bitcraftWidth/2], -3);

      // Overwriting the default icon parameters
      delete L.Icon.Default.prototype._getIconUrl;
      L.Icon.Default.mergeOptions({
        "iconUrl": iconsManifest['Hex_Logo'],
        "iconRetinaUrl": iconsManifest['Hex_Logo'],
        "iconSize": [28,28],
        "iconAnchor": [14,14],
        "popupAnchor": [0,-14],
        "tooltipAnchor": [-14,0],
        "shadowUrl": null,
        "shadowSize": null,
        "shadowAnchor": null,
        "shadowRetinaUrl": null
      });

      smallSizeIcon = [[26, 26],[13, 13],[0, -13]];
      mediumSizeIcon = [[44, 44],[22, 22],[0, -22]];
      largeSizeIcon = [[50, 50],[25, 25],[0, -25]];

      function createMapIcon(iconUrl, iconConfig = [[32, 32],[16, 16],[0, -16]]) {
        return L.icon({
          iconUrl: iconUrl || iconsManifest['Hex_Logo'],
          iconSize: iconConfig[0],
          iconAnchor: iconConfig[1],
          popupAnchor: iconConfig[2],
          shadowUrl: null,
          shadowSize: null,
          shadowAnchor: null
        });
      };

      const caveIcons = [
        createMapIcon(iconsManifest['t1']),
        createMapIcon(iconsManifest['t2']),
        createMapIcon(iconsManifest['t3']),
        createMapIcon(iconsManifest['t4']),
        createMapIcon(iconsManifest['t5']),
        createMapIcon(iconsManifest['t6']),
        createMapIcon(iconsManifest['t7']),
        createMapIcon(iconsManifest['t8']),
        createMapIcon(iconsManifest['t9']),
        createMapIcon(iconsManifest['t10'])
      ];

      const claimIcons = [
        createMapIcon(iconsManifest['claimT0']),
        createMapIcon(iconsManifest['claimT1']),
        createMapIcon(iconsManifest['claimT2']),
        createMapIcon(iconsManifest['claimT3']),
        createMapIcon(iconsManifest['claimT4']),
        createMapIcon(iconsManifest['claimT5']),
        createMapIcon(iconsManifest['claimT6']),
        createMapIcon(iconsManifest['claimT7']),
        createMapIcon(iconsManifest['claimT8']),
        createMapIcon(iconsManifest['claimT9']),
        createMapIcon(iconsManifest['claimT10'])
      ];

      const ruinedIcon = createMapIcon(iconsManifest['ruinedCity']);
      const templeIcon = createMapIcon(iconsManifest['temple']);
      const treeIcon = createMapIcon(iconsManifest['travelerTree']);

      const treesLayer = L.layerGroup();
      const ruinedLayer = L.layerGroup();
      const templesLayer = L.layerGroup();
      const banksLayer = L.layerGroup();
      const marketsLayer = L.layerGroup();
      const waystonesLayer = L.layerGroup();
      const gridsLayer =  L.layerGroup();
      const waypointsLayer = L.layerGroup();

      const claimT0Layer = L.layerGroup();
      const claimT1Layer = L.layerGroup();
      const claimT2Layer = L.layerGroup();
      const claimT3Layer = L.layerGroup();
      const claimT4Layer = L.layerGroup();
      const claimT5Layer = L.layerGroup();
      const claimT6Layer = L.layerGroup();
      const claimT7Layer = L.layerGroup();
      const claimT8Layer = L.layerGroup();
      const claimT9Layer = L.layerGroup();
      const claimT10Layer = L.layerGroup();

      const claimLayers = [
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer
      ];

      const allClaims = L.layerGroup(claimLayers);
      const searchGroup = L.layerGroup(claimLayers.concat(ruinedLayer));

      const caveT1Layer = L.layerGroup();
      const caveT2Layer = L.layerGroup();
      const caveT3Layer = L.layerGroup();
      const caveT4Layer = L.layerGroup();
      const caveT5Layer = L.layerGroup();
      const caveT6Layer = L.layerGroup();
      const caveT7Layer = L.layerGroup();
      const caveT8Layer = L.layerGroup();
      const caveT9Layer = L.layerGroup();
      const caveT10Layer = L.layerGroup();

      const caveLayers = [
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      ];

      const allCaves = L.layerGroup(caveLayers);

      const genericToggle = {
        "Wonders": treesLayer,
        "Temples": templesLayer,
        "Ruined Cities": ruinedLayer,
        "Banks": banksLayer,
        "Markets": marketsLayer,
        "Waystones": waystonesLayer,
        "Grids": gridsLayer,
        "Waypoints": waypointsLayer,
      };

      const claimsToggle = {
        "Claims": allClaims
      };

      const claimsTierToggle = {
        "Claims T0": claimT0Layer,
        "Claims T1": claimT1Layer,
        "Claims T2": claimT2Layer,
        "Claims T3": claimT3Layer,
        "Claims T4": claimT4Layer,
        "Claims T5": claimT5Layer,
        "Claims T6": claimT6Layer,
        "Claims T7": claimT7Layer,
        "Claims T8": claimT8Layer,
        "Claims T9": claimT9Layer,
        "Claims T10": claimT10Layer
      };

      const cavesToggle = {
        "Caves": allCaves
      };

      const cavesTierToggle = {
        "Caves T1": caveT1Layer,
        "Caves T2": caveT2Layer,
        "Caves T3": caveT3Layer,
        "Caves T4": caveT4Layer,
        "Caves T5": caveT5Layer,
        "Caves T6": caveT6Layer,
        "Caves T7": caveT7Layer,
        "Caves T8": caveT8Layer,
        "Caves T9": caveT9Layer,
        "Caves T10": caveT10Layer
      };

      const allLayers = {
        treesLayer, templesLayer, ruinedLayer, banksLayer,
        marketsLayer, waystonesLayer, waypointsLayer,
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer,
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      };

      // This is leaflet.search plugin configuration
      // This plugin need a "title" parameter in each marker to find stuff
      const searchControlOptions = {
        position:'topleft',		
        layer: searchGroup,
        initial: false,
        marker: false,
        firstTipSubmit: true,
        zoom: 0
      };
      const searchControl = new L.Control.Search(searchControlOptions);

      // Load the marker if it is no already on the map
      searchControl.on('search:locationfound', function(marker) {
        if (!map.hasLayer(marker.layer)) {
          map.addLayer(marker.layer);
        }
      });

      // -------------------------------------- //
      // This is getting replaced
      // -------------------------------------- //
      async function loadTreesGeoJson() {
        const file = await fetch('assets/markers/trees.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {
            
            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: treeIcon }
            )
            .bindPopup(popupText)
            .addTo(treesLayer);
          }
        });
      };
      async function loadTemplesGeoJson() {
        const file = await fetch('assets/markers/temples.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: templeIcon }
            )
            .bindPopup(popupText)
            .addTo(templesLayer);
          }
        });
      };
      async function loadRuinedGeoJson() {
        const file = await fetch('assets/markers/ruined.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { 
                title: feature.properties.name + ' N '+ coords[0] + ' E ' + coords[1],
                icon: ruinedIcon
              }
            )
            .bindPopup(popupText)
            .addTo(ruinedLayer);
          }
        });
      };
      async function loadClaimsGeoJson() {
        const file = await fetch('assets/markers/claims.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

          const coords = readableCoordinates(latlng);
          const name = '<a href="' + 'https://bitjita.com/claims/' + feature.properties.entityId + '" target="_blank">' + feature.properties.name + '</a>';
          const tier = ' (T' + feature.properties.tier + ')' + '<br>';
          const loc = 'N '+ coords[0] + ' E ' + coords[1] + '<br>';
          const has_bank = 'Bank : ' + (feature.properties.has_bank ? 'Yes' : 'No') + '<br>';
          const has_market = 'Market : ' + (feature.properties.has_market ? 'Yes' : 'No') + '<br>';
          const has_Waystone = 'Waystone : ' + (feature.properties.has_waystone ? 'Yes' : 'No');
          const popupText = name + tier + loc + has_bank + has_market + has_Waystone;

            const marker = L.marker(
              latlng,
              {
                title: feature.properties.name + ' N '+ coords[0] + ' E ' + coords[1],
                icon: claimIcons[feature.properties.tier]
              }
            );

            marker.bindPopup(popupText)
            marker.addTo(claimLayers[feature.properties.tier]);

            if (feature.properties.has_bank) {
              marker.addTo(banksLayer)
            }
            if (feature.properties.has_market) {
              marker.addTo(marketsLayer)
            }
            if (feature.properties.has_waystone) {
              marker.addTo(waystonesLayer)
            }

            return marker;
          }
        });
      };
      async function loadCavesGeoJson() {
        const file = await fetch('assets/markers/caves.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: caveIcons[feature.properties.tier-1] }
            )
            .bindPopup(popupText)
            .addTo(caveLayers[feature.properties.tier-1]);
          }
        });
      };
      // -------------------------------------- //
      // This is getting replaced
      // -------------------------------------- //

      // Function to convert to N E coordinate people know about
      function readableCoordinates(latlng) {
        return [
          Math.round(latlng.lat / 23040 * 7676),
          Math.round(latlng.lng / 23040 * 7676)
        ]; 
      };
      
      // Bit of code to get the position at the mouse and display it
      const coordDisplay = document.getElementById('coords');
      map.on('mousemove', function (e) {
        const coords = readableCoordinates(e.latlng);
        coordDisplay.innerText = 'N: ' + coords[0] + ' E: ' + coords[1];
      });

      function loadGeoJsonFromHash() {
        const hashFromUrl = location.hash.slice(1);
        if(!hashFromUrl) return;
        const geoJson = validateGeoJson(hashFromUrl);
        paintGeoJson(geoJson, waypointsLayer);
        map.addLayer(waypointsLayer);
      };

      async function loadGeoJsonFromGist() {
        const gistIdFromUrl = new URLSearchParams(window.location.search).get('gistId');
        if(!gistIdFromUrl || gistIdFromUrl.length > 50) return;
        const response = await fetch('https://gist.githubusercontent.com/' + gistIdFromUrl + '/raw');
        const content = await response.text()
        const geoJson = validateGeoJson(content);
        paintGeoJson(geoJson, waypointsLayer);
        map.addLayer(waypointsLayer);
      };

      async function loadGeoJsonFromFile(fileUrl) {
        const file = await fetch(fileUrl);
        const content = await file.text()
        const geoJson = validateGeoJson(content);
        paintGeoJson(geoJson, gridsLayer);
      };

      function paintGeoJson(geoJson, layer) {
        L.geoJSON(geoJson, {
          pointToLayer: function(feature, latlng) {

            if (feature.properties?.type === 'tooltip') {
              return new L.popup(
                latlng,
                {
                  autoPan: false,
                  autoClose: false,
                }
              ).setContent(feature.properties.popupText);
            }

            if (feature.properties?.makeCanvas) {
              if (feature.properties.ragius) {
                return new L.CircleMarker(latlng, {radius: feature.properties.ragius});
              } else {
                return new L.CircleMarker(latlng, {radius: 1});
              } 
            }

            map.createPane('markerOnTop');
            map.getPane('markerOnTop').style.zIndex = 999;
            const waypointIcon = createMapIcon('assets/icons/waypoint.png', mediumSizeIcon);

            return L.marker(
              latlng,
              { icon: waypointIcon, pane: 'markerOnTop' }
            );
          },

          style: function(feature) {
            return {
              color: feature.properties?.color || "#3388ff",
              weight: feature.properties?.weight || 3,
              opacity: feature.properties?.opacity || 1,
              fillColor: feature.properties?.fillColor || "#3388ff",
              fillOpacity: feature.properties?.fillOpacity ?? 0.2
            };
          },

          onEachFeature: function(feature, layer) {
            if (feature.properties?.popupText) {
              const popupText = feature.properties.popupText;
              let finalPopupText = '';

              if (Array.isArray(popupText)) {
                for (const line of popupText) {
                  finalPopupText += line + '<br>';
                }
              } else {
                finalPopupText = popupText;
              }
              layer.bindPopup(finalPopupText);
            }

            if (feature.properties?.turnLayerOn) {
              if (Array.isArray(feature.properties.turnLayerOn)) {
                for (const layerName of feature.properties.turnLayerOn) {
                  const layer = allLayers[layerName];
                  if (layer) map.addLayer(layer);
                }
              } else {
                const layer = allLayers[feature.properties.turnLayerOn];
                if (layer) map.addLayer(layer);
              }
            }

            if (feature.properties?.turnLayerOff) {
              if (Array.isArray(feature.properties.turnLayerOff)) {
                for (const layerName of feature.properties.turnLayerOff) {
                  const layer = allLayers[layerName];
                  if (layer) map.removeLayer(layer);
                }
              } else {
                const layer = allLayers[feature.properties.turnLayerOff];
                if (layer) map.removeLayer(layer);
              }
            }

            if (feature.properties?.flyTo && feature.properties?.zoomTo) {
              map.flyTo(feature.properties.flyTo, feature.properties.zoomTo);
            } else if (layer?.getBounds && !feature.properties.noPan) {
              map.fitBounds(layer.getBounds());
            }
          }
        }).addTo(layer);
      };

      // Default layer to show on map opening
      treesLayer.addTo(map);
      templesLayer.addTo(map);
      ruinedLayer.addTo(map);
      searchControl.addTo(map);

      L.control.layers(null, genericToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsTierToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesTierToggle, { collapsed: false }).addTo(map);

      function escapeHTML(string) {
        return string
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#x27;");
      };

      function validateGeoJson(untrustedString) {
        if (untrustedString.constructor.name !== 'String') {
          throw new Error('untrustedString be a string');
        }

        const decodedString = decodeURI(untrustedString);
        const jsonFormString = JSON.parse(decodedString);

        if (Array.isArray(jsonFormString)) {
          throw new Error('geoJson must not be an array');
        }

        if (jsonFormString.type !== 'FeatureCollection') {
          throw new Error('geoJson doesnt have FeatureCollection');
        }

        if (!jsonFormString.features || !Array.isArray(jsonFormString.features)) {
          throw new Error('geoJson doesnt have features or features isnt array');
        }

        for (const feature of jsonFormString.features) {
          if (feature.properties?.popupText) {
            if (
              Array.isArray(feature.properties.popupText)
              && feature.properties.popupText.every(value => value.constructor.name === 'String')
            ) {
              feature.properties.popupText = feature.properties.popupText.map(escapeHTML);
            } else if (feature.properties.popupText.constructor.name === 'String') {
              feature.properties.popupText = escapeHTML(feature.properties.popupText);
            } else {
              throw new Error('popupText must be string or array of strings');
            }
          }
        }
        return jsonFormString;
      };

      // Load files
      loadTreesGeoJson();
      loadTemplesGeoJson();
      loadRuinedGeoJson();
      loadCavesGeoJson();
      loadClaimsGeoJson();

      // Load from gist / load from hash / load from file
      loadGeoJsonFromGist();
      loadGeoJsonFromHash();
      loadGeoJsonFromFile('assets/markers/grids.geojson');
    </script>
  </body>
</html>
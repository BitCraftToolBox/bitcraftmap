#!/usr/bin/env python3
"""
WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

This script was generated by ChatGPT. It work but I have no control over it
Use at your own risk

WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

Hexagon merge (pointy-top) around points → MultiPolygon GeoJSON
- Builds a regular hex around each point.
- Size so each hex reaches its nearest neighbor (per-point mode) OR fixed size.
- Merges touching/overlapping hexes.
- Outputs GeoJSON with ALL coordinates rounded to 2 decimals.
- Uses pointy-top orientation by default.

Requires: shapely  (pip install shapely)
Optional: scipy (KDTree for fast nearest neighbor). If missing, falls back.

Usage:
python hex_merge_pointy.py input.json output.geojson

Per-point sizing (default):
python hex_merge_pointy.py input.json output.geojson

Fixed size:
python hex_merge_pointy.py input.json output.geojson --mode fixed --apothem 0.6

Tune union batch size:
python hex_merge_pointy.py input.json output.geojson --batch 5000
"""

import argparse, json, math, re, sys
from typing import List, Tuple, Dict, Any

try:
    from shapely.geometry import Polygon, MultiPolygon
    from shapely.ops import unary_union
except ImportError:
    print("ERROR: shapely is required. Install with: pip install shapely", file=sys.stderr)
    sys.exit(1)

Point = Tuple[float, float]

# ---------- I/O: read points ----------
def load_points_from_text(txt: str) -> List[Point]:
    # Try proper JSON first
    try:
        obj = json.loads(txt)
        pts = extract_points_from_geojson(obj)
        if pts:
            return pts
    except Exception:
        pass
    # Fallback: regex for [x,y]
    pairs = re.findall(r'\[\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*\]', txt)
    pts = [(float(x), float(y)) for x,y in pairs]
    if not pts:
        raise ValueError("No [x,y] pairs found in input.")
    return pts

def extract_points_from_geojson(obj: Any) -> List[Point]:
    out: List[Point] = []
    def push(v):
        if isinstance(v, list) and len(v) >= 2:
            out.append((float(v[0]), float(v[1])))
    def walk(node):
        if isinstance(node, dict):
            t = node.get("type")
            if t == "FeatureCollection":
                for f in node.get("features", []): walk(f)
            elif t == "Feature":
                g = node.get("geometry"); 
                if g: walk(g)
            else:
                walk(node.get("coordinates"))
        elif isinstance(node, list):
            if node and isinstance(node[0], (int,float)):
                push(node)
            else:
                for s in node: walk(s)
    walk(obj)
    return out

# ---------- Geometry helpers ----------
def hex_vertices_pointy(center: Point, apothem: float) -> List[Point]:
    """
    Regular hexagon (pointy-top) around center with given apothem a (center→side).
    For a regular hex: side length s = 2a/√3, circumradius R = s.
    Vertex order CCW starting at "top" vertex.
    """
    a = apothem
    s = 2*a/math.sqrt(3.0)  # side length
    R = s                   # circumradius center→vertex
    x, y = center
    # angles (deg) for pointy-top: 90, 150, 210, 270, 330, 30 (CCW)
    angles = [90, 150, 210, 270, 330, 30, 90]
    verts = []
    for deg in angles:
        rad = math.radians(deg)
        verts.append((x + R*math.cos(rad), y + R*math.sin(rad)))
    return verts

# ---------- Nearest-neighbor distances ----------
def nearest_dist_per_point(points: List[Point]) -> List[float]:
    # Try scipy KDTree
    try:
        from scipy.spatial import cKDTree as KDTree  # type: ignore
        tree = KDTree(points)
        dists, _ = tree.query(points, k=2)
        return [float(d[1]) for d in dists]
    except Exception:
        pass

    # Grid-int heuristic (fast)
    is_intish = all(abs(px - round(px)) < 1e-9 and abs(py - round(py)) < 1e-9 for px,py in points[:min(2000,len(points))])
    if is_intish:
        S = {(int(px), int(py)) for px,py in points}
        out = []
        OFFS = [(1,0),(-1,0),(0,1),(0,-1),(1,1),(1,-1),(-1,1),(-1,-1)]
        for px,py in points:
            ipx, ipy = int(px), int(py)
            md = float("inf")
            for dx,dy in OFFS:
                if (ipx+dx, ipy+dy) in S:
                    md = min(md, 1.0 if dx==0 or dy==0 else math.sqrt(2.0))
                    if md == 1.0:
                        break
            if math.isinf(md):
                # small ring search up to r=4
                found = False
                for r in range(2,5):
                    for dx in range(-r, r+1):
                        for dy in (-r, r) if abs(dx) in (0,r) else (-r, r):
                            if (ipx+dx, ipy+dy) in S:
                                md = math.hypot(dx,dy); found=True; break
                        if found: break
                    if found: break
                if math.isinf(md):
                    md = 1e9
            out.append(md)
        return out

    # Last-resort: coarse sample
    sample = points[::max(1, len(points)//5000)]
    try:
        from scipy.spatial import cKDTree as KDTree  # type: ignore
        tree = KDTree(sample)
        dmins = []
        for p in points:
            d,_ = tree.query([p], k=1)
            dmins.append(float(d[0]) if hasattr(d, "__len__") else float(d))
        return dmins
    except Exception:
        return [1.0 for _ in points]

# ---------- Batch unary union ----------
def batch_union(polys: List[Polygon], batch: int):
    chunks = []
    total = len(polys)
    for i in range(0, total, batch):
        part = unary_union(polys[i:i+batch])
        chunks.append(part)
        print(f"Unioned batch {i//batch+1}/{math.ceil(total/batch)} (batch size {len(polys[i:i+batch])})")
    return unary_union(chunks)

# ---------- Round coordinates ----------
def round_coords_2(obj: Any) -> Any:
    """
    Convert a shapely Polygon/MultiPolygon to GeoJSON-like coords with all numbers rounded to 2 decimals.
    """
    def round_pt(pt): return [round(pt[0], 2), round(pt[1], 2)]
    def round_ring(ring): return [round_pt(p) for p in ring]
    def poly_coords(poly: Polygon):
        exterior = round_ring(list(poly.exterior.coords))
        interiors = [round_ring(list(r.coords)) for r in poly.interiors]
        return [exterior] + interiors

    if isinstance(obj, Polygon):
        return [poly_coords(obj)]
    elif isinstance(obj, MultiPolygon):
        return [poly_coords(g) for g in obj.geoms]
    else:
        # Try to collect polygons from geometry collections
        geoms = getattr(obj, "geoms", [])
        polys = [g for g in geoms if isinstance(g, Polygon)]
        return [poly_coords(g) for g in polys]

def stagger_points(points: List[Point]) -> List[Point]:
    """
    Shift every odd 'row' by +0.5 in x.
    Assumes y is integer-like (row index).
    """
    out = []
    for x, y in points:
        # If row (y) is odd
        if int(round(y)) % 2 == 1:
            out.append((x + 0.25, y))
        else:
            out.append((x - 0.25, y))
    return out

# ---------- Main ----------
def main():
    ap = argparse.ArgumentParser(description="Pointy-top hex merge around points → rounded MultiPolygon GeoJSON")
    ap.add_argument("input", help="Input file (GeoJSON or text with [x,y] pairs)")
    ap.add_argument("output", help="Output GeoJSON file")
    ap.add_argument("--mode", choices=["per-point","fixed"], default="per-point",
                    help="Size mode: per-point nearest-neighbor (default) or fixed")
    ap.add_argument("--apothem", type=float, default=None,
                    help="Apothem if --mode fixed. If omitted, defaults to 0.6")
    ap.add_argument("--batch", type=int, default=5000,
                    help="Union batch size for performance")
    ap.add_argument("--prop", action="append", default=[], metavar="KEY=VALUE",
                    help="Add property to output Feature (repeatable)")
    args = ap.parse_args()

    txt = open(args.input, "r", encoding="utf-8").read()
    pts = load_points_from_text(txt)
    
    pts = stagger_points(pts)
    print("[Preprocess] Staggered odd rows")
    
    n = len(pts)
    print(f"Loaded {n} points")

    # Decide apothem(s)
    if args.mode == "fixed":
        a = args.apothem if args.apothem is not None else 0.6
        apothems = [float(a)] * n
        print(f"Using fixed apothem={a}")
    else:
        print("Computing nearest-neighbor distances ...")
        d_nn = nearest_dist_per_point(pts)
        # Ensure hexes touch nearest neighbor: set apothem = d/2 (inscribed circle radius)
        apothems = [ (d/2.0 if d < 1e8 else 0.6) for d in d_nn ]
        print("Done computing per-point apothems.")

    # Build pointy-top hexagons
    hexes: List[Polygon] = []
    step = max(1, n // 100)
    for i, (p, a) in enumerate(zip(pts, apothems), 1):
        verts = hex_vertices_pointy(p, a)
        hexes.append(Polygon(verts))
        if i % (step*10) == 0 or i == n:
            print(f"Built {i}/{n} hexagons")

    # Merge them
    print("Merging hexagons ...")
    merged = batch_union(hexes, args.batch)

    # Normalize to MultiPolygon
    if merged.geom_type == "Polygon":
        mpoly = MultiPolygon([merged])
    elif merged.geom_type == "MultiPolygon":
        mpoly = merged
    else:
        parts = [g for g in getattr(merged, "geoms", []) if g.geom_type in ("Polygon","MultiPolygon")]
        mpoly = unary_union(parts)
        if mpoly.geom_type == "Polygon":
            mpoly = MultiPolygon([mpoly])

    # Properties
    props: Dict[str,str] = {}
    for kv in args.prop:
        if "=" in kv:
            k,v = kv.split("=",1)
            props[k] = v

    # Round to 2 decimals and write GeoJSON
    coords = round_coords_2(mpoly)  # [[ [ [x,y],... ], [hole...], ... ], ...]
    feature = {
        "type": "Feature",
        "properties": props,
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": coords
        }
    }
    fc = {"type": "FeatureCollection", "features": [feature]}
    with open(args.output, "w", encoding="utf-8") as f:
        json.dump(fc, f, ensure_ascii=False,separators=(',', ':'))
    print(f"Wrote {len(mpoly.geoms) if hasattr(mpoly,'geoms') else 1} polygon(s) → {args.output}")

if __name__ == "__main__":
    main()
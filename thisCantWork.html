<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <style>
      html, body { height: 100%; margin: 0; }
      #map { height: 100%; }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      const map = L.map('map', { center: [0, 0], zoom: 2 });

      // ---- helper: draw a hex path ----
      function hexPath(ctx, cx, cy, r) {
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const a = Math.PI / 3 * i;
          const x = cx + r * Math.cos(a);
          const y = cy + r * Math.sin(a);
          i ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
        }
        ctx.closePath();
      }

      const HexImageLayer = L.GridLayer.extend({
        initialize: function(opts) {
          L.GridLayer.prototype.initialize.call(this, opts);
          this._img = new Image();
          // You can point this to your image file:
          this._img.crossOrigin = 'anonymous'; // safe even if not required
          this._img.src = opts.imageUrl || 'https://picsum.photos/1024/768';
          this._imgLoaded = false;
          this._img.onload = () => {
            this._imgLoaded = true;
            this.redraw();
          };
        },

        // Map a world pixel (global, at current zoom) to image pixel
        _worldToImage: function(wx, wy, z) {
          const tileSize = this.getTileSize().x;
          const worldSize = tileSize * Math.pow(2, z); // size in px of the whole world at zoom z
          const u = (wx % worldSize + worldSize) % worldSize / worldSize; // wrap
          const v = (wy % worldSize + worldSize) % worldSize / worldSize;
          const sx = u * this._img.width;
          const sy = v * this._img.height;
          return { sx, sy };
        },

        createTile: function(coords) {
          const tileSize = this.getTileSize().x;
          const tile = L.DomUtil.create('canvas', 'leaflet-tile');
          tile.width = tileSize;
          tile.height = tileSize;
          const ctx = tile.getContext('2d');

          // If image not ready yet, draw a placeholder; we'll redraw when it loads
          if (!this._imgLoaded) {
            ctx.fillStyle = '#eee';
            ctx.fillRect(0, 0, tileSize, tileSize);
            ctx.fillStyle = '#555';
            ctx.font = '12px sans-serif';
            ctx.fillText('loadingâ€¦', 6, 16);
            return tile;
          }

          // ---- draw hex mosaic ----
          const r = 16;                             // hex radius (tweak me)
          const stepX = r * 1.5;                    // horizontal step
          const stepY = r * Math.sqrt(3);           // vertical step

          // tile's top-left global pixel (world coords)
          const tileOriginX = coords.x * tileSize;
          const tileOriginY = coords.y * tileSize;

          for (let row = -1; row * stepY < tileSize + stepY; row++) {
            const y = row * stepY + r; // center y
            const offsetX = (row % 2 === 0) ? r : r + 0.75 * r; // staggered columns
            for (let col = -1; col * stepX < tileSize + stepX; col++) {
              const x = col * stepX + offsetX;

              // skip hexes whose center is far outside the tile
              if (x < -2*r || x > tileSize + 2*r || y < -2*r || y > tileSize + 2*r) continue;

              // Destination hex bounding box (approx) to use for drawImage
              const dstX = x - r;
              const dstY = y - r;
              const dstW = r * 2;
              const dstH = r * 2;

              // Compute corresponding source point from world->image using the hex center
              const worldX = tileOriginX + x;
              const worldY = tileOriginY + y;
              const { sx, sy } = this._worldToImage(worldX, worldY, coords.z);

              // Source rect size proportional to destination (simple mapping)
              const sw = (dstW / (tileSize * Math.pow(2, coords.z))) * this._img.width;
              const sh = (dstH / (tileSize * Math.pow(2, coords.z))) * this._img.height;

              // Clip to hex, then draw that slice of the image into the hex
              ctx.save();
              hexPath(ctx, x, y, r);
              ctx.clip();
              ctx.drawImage(this._img, sx - sw/2, sy - sh/2, sw, sh, dstX, dstY, dstW, dstH);
              ctx.restore();

              // Optional outline
              // ctx.strokeStyle = 'rgba(0,0,0,0.25)';
              // ctx.stroke();
            }
          }

          return tile;
        }
      });

      // Add the layer
      new HexImageLayer({
        tileSize: 256,
        imageUrl: 'http://localhost:8000/assets/maps/small.png' // <-- replace with your image URL
      }).addTo(map);
    </script>
  </body>
</html>
<!DOCTYPE html>
<html>
	<head>
		<title>Bitcraft Game Map</title>
    <link rel="icon" type="image/x-icon" href="assets/icons/MapCompass.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
		<link rel="stylesheet" href="assets/search/leaflet-search.src.css" crossorigin=""/>

		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js" crossorigin=""></script>
		<script src="assets/search/leaflet-search.src.js" crossorigin=""></script>

		<style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
			#map {
				height: 100vh;
				width: 100%;
        background-color: #2a3145;
			}
      #coords {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 5px 10px;
        z-index: 1000;
        font-family: monospace;
	      border-radius:.25em;
      }
    </style>
	</head>

	<body>
    <div id="map"></div>
		<div id="coords"></div>
    <script>

      // Documentation of my struggle with the map
      // When cropping the top of the image you will get a rectangle map. This is what we want but leaflet
      // Will retransform that rectangle to a square, whatever the value I put in widht and height
      // This looks bad
      // However if I load the map with the added ocean at the top, the coordinate system will be screwed
      // Conclusion, We multiply the height by the hexagon ratio to get what would be the real height with added ocean

      // The image itself is this size in pixel
			const imageWidth = 7200;
			const imageHeight = 7200;

      // Objects in Bitcraft are positionned with coordinates from 0 to 23040
      const bitcraftWidth = 23040;  
      const bitcraftHeight = 23040 * 1.1547005; // Extra ocean on top

      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -6,
        maxZoom: 6,
        zoomSnap: 0.1,
        attributionControl: false, // Remove watermark
        zoomControl: false, // Remove the zoom control top left
        preferCanvas: true,
        boxZoom: true // kinda useless (shift + drag left click mouse) might remove
      });

      // When placing a marker on the map we will use this 0-23040 system
      // The extra 1.15 we added doesnt mater, nothing will be placed there
      const mapBounds = [[0, 0], [bitcraftHeight, bitcraftWidth]];
      L.imageOverlay('assets/maps/map.png', mapBounds).addTo(map);

      //               N                     E
      //              lat                   lgt
      //           locationZ             locationX
      //         bottom to top         left to right
      //               v                     v
      map.setView([bitcraftHeight/2, bitcraftWidth/2], -3);

      function createMapIcon(iconUrl, iconConfig = [[32, 32],[16, 16],[0, -16]]) {
        return L.icon({
          iconUrl: iconUrl,
          iconSize: iconConfig[0],
          iconAnchor: iconConfig[1],
          popupAnchor: iconConfig[2],
          shadowUrl: null,
          shadowSize: null,
          shadowAnchor: null
        });
      };

      smallSizeIcon = [[26, 26],[13, 13],[0, -13]];
      mediumSizeIcon = [[44, 44],[22, 22],[0, -22]];
      largeSizeIcon = [[50, 50],[25, 25],[0, -25]];
     
      const caveIcons = [
        createMapIcon('assets/images/ore/t1.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t2.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t3.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t4.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t5.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t6.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t7.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t8.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t9.png', smallSizeIcon),
        createMapIcon('assets/images/ore/t10.png', smallSizeIcon)
      ];

      const claimIcons = [
        createMapIcon('assets/images/claim/t0.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t1.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t2.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t3.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t4.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t5.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t6.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t7.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t8.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t9.png', mediumSizeIcon),
        createMapIcon('assets/images/claim/t10.png', mediumSizeIcon)
      ];

      const ruinedIcon = createMapIcon('assets/images/claim/ruined.png', mediumSizeIcon);
      const templeIcon = createMapIcon('assets/images/poi/temple.svg');
      const treeIcon = createMapIcon('assets/images/poi/tree.svg');

      const treesLayer = L.layerGroup();
      const ruinedLayer = L.layerGroup();
      const templesLayer = L.layerGroup();
      const banksLayer = L.layerGroup();
      const marketsLayer = L.layerGroup();
      const waystonesLayer = L.layerGroup();
      const waypointsLayer = L.layerGroup();

      const claimT0Layer = L.layerGroup();
      const claimT1Layer = L.layerGroup();
      const claimT2Layer = L.layerGroup();
      const claimT3Layer = L.layerGroup();
      const claimT4Layer = L.layerGroup();
      const claimT5Layer = L.layerGroup();
      const claimT6Layer = L.layerGroup();
      const claimT7Layer = L.layerGroup();
      const claimT8Layer = L.layerGroup();
      const claimT9Layer = L.layerGroup();
      const claimT10Layer = L.layerGroup();

      const claimLayers = [
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer
      ];

      const allClaims = L.layerGroup(claimLayers);
      const searchGroup = L.layerGroup(claimLayers.concat(ruinedLayer));

      const caveT1Layer = L.layerGroup();
      const caveT2Layer = L.layerGroup();
      const caveT3Layer = L.layerGroup();
      const caveT4Layer = L.layerGroup();
      const caveT5Layer = L.layerGroup();
      const caveT6Layer = L.layerGroup();
      const caveT7Layer = L.layerGroup();
      const caveT8Layer = L.layerGroup();
      const caveT9Layer = L.layerGroup();
      const caveT10Layer = L.layerGroup();

      const caveLayers = [
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      ];

      const allCaves = L.layerGroup(caveLayers);

      const genericToggle = {
        "Wonders": treesLayer,
        "Temples": templesLayer,
        "Ruined Cities": ruinedLayer,
        "Banks": banksLayer,
        "Markets": marketsLayer,
        "Waystones": waystonesLayer,
        "Waypoints": waypointsLayer,
      };

      const claimsToggle = {
        "Claims": allClaims
      };

      const claimsTierToggle = {
        "Claims T0": claimT0Layer,
        "Claims T1": claimT1Layer,
        "Claims T2": claimT2Layer,
        "Claims T3": claimT3Layer,
        "Claims T4": claimT4Layer,
        "Claims T5": claimT5Layer,
        "Claims T6": claimT6Layer,
        "Claims T7": claimT7Layer,
        "Claims T8": claimT8Layer,
        "Claims T9": claimT9Layer,
        "Claims T10": claimT10Layer
      };

      const cavesToggle = {
        "Caves": allCaves
      };

      const cavesTierToggle = {
        "Caves T1": caveT1Layer,
        "Caves T2": caveT2Layer,
        "Caves T3": caveT3Layer,
        "Caves T4": caveT4Layer,
        "Caves T5": caveT5Layer,
        "Caves T6": caveT6Layer,
        "Caves T7": caveT7Layer,
        "Caves T8": caveT8Layer,
        "Caves T9": caveT9Layer,
        "Caves T10": caveT10Layer
      };

      const allLayers = {
        treesLayer, templesLayer, ruinedLayer, banksLayer,
        marketsLayer, waystonesLayer, waypointsLayer,
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer,
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      };

      // This is leaflet.search plugin configuration
      // This plugin need a "title" parameter in each marker to find stuff
      const searchControlOptions = {
        position:'topleft',		
        layer: searchGroup,
        initial: false,
        marker: false,
        firstTipSubmit: true,
        zoom: 0
      };
      const searchControl = new L.Control.Search(searchControlOptions);

      // Load the marker if it is no already on the map
      searchControl.on('search:locationfound', function(marker) {
        if (!map.hasLayer(marker.layer)) {
          map.addLayer(marker.layer);
        }
      });

      // -------------------------------------- //
      // This is getting replaced
      // -------------------------------------- //
      async function loadTreesGeoJson() {
        const file = await fetch('assets/markers/trees.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {
            
            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: treeIcon }
            )
            .bindPopup(popupText)
            .addTo(treesLayer);
          }
        });
      };
      async function loadTemplesGeoJson() {
        const file = await fetch('assets/markers/temples.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: templeIcon }
            )
            .bindPopup(popupText)
            .addTo(templesLayer);
          }
        });
      };
      async function loadRuinedGeoJson() {
        const file = await fetch('assets/markers/ruined.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { 
                title: feature.properties.name,
                icon: ruinedIcon
              }
            )
            .bindPopup(popupText)
            .addTo(ruinedLayer);
          }
        });
      };
      async function loadClaimsGeoJson() {
        const file = await fetch('assets/markers/claims.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

          const coords = readableCoordinates(latlng);
          const name = '<a href="' + 'https://bitjita.com/claims/' + feature.properties.entityId + '" target="_blank">' + feature.properties.name + '</a>';
          const tier = ' (T' + feature.properties.tier + ')' + '<br>';
          const loc = 'N '+ coords[0] + ' E ' + coords[1] + '<br>';
          const has_bank = 'Bank : ' + (feature.properties.has_bank ? 'Yes' : 'No') + '<br>';
          const has_market = 'Market : ' + (feature.properties.has_market ? 'Yes' : 'No') + '<br>';
          const has_Waystone = 'Waystone : ' + (feature.properties.has_waystone ? 'Yes' : 'No');
          const popupText = name + tier + loc + has_bank + has_market + has_Waystone;

            const marker = L.marker(
              latlng,
              {
                title: feature.properties.name,
                icon: claimIcons[feature.properties.tier]
              }
            );

            marker.bindPopup(popupText)
            marker.addTo(claimLayers[feature.properties.tier]);

            if (feature.properties.has_bank) {
              marker.addTo(banksLayer)
            }
            if (feature.properties.has_market) {
              marker.addTo(marketsLayer)
            }
            if (feature.properties.has_waystone) {
              marker.addTo(waystonesLayer)
            }

            return marker;
          }
        });
      };
      async function loadCavesGeoJson() {
        const file = await fetch('assets/markers/caves.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: caveIcons[feature.properties.tier-1] }
            )
            .bindPopup(popupText)
            .addTo(caveLayers[feature.properties.tier-1]);
          }
        });
      };
      // -------------------------------------- //
      // This is getting replaced
      // -------------------------------------- //

      // Function to convert to N E coordinate people know about
      function readableCoordinates(latlng) {
        return [
          Math.round(latlng.lat / 23040 * 7676),
          Math.round(latlng.lng / 23040 * 7676)
        ]; 
      };
      
      // Bit of code to get the position at the mouse and display it
      // Could display biome later
      // Could display ingame time, travaler task reset timer
      // Could turn on an of with an optional checkbox
      const coordDisplay = document.getElementById('coords');
      map.on('mousemove', function (e) {
        const coords = readableCoordinates(e.latlng);
        coordDisplay.innerText = 'N: ' + coords[0] + ' E: ' + coords[1];
      });

      function loadGeoJsonFromHash() {
        const hashFromUrl =
          location.hash
          .slice(1)              // Removing the "#"
          .replace(/%20/g, ' ')  // Names can contain spaces
          .replace(/%22/g, '"')  // We need " for json
          .replace(/%7B/g, '{')  // sometimes discord remove these
          .replace(/%7D/g, '}'); // sometimes discord remove these
        if (!hashFromUrl) return; // No hash to load
        const geoJson = JSON.parse(hashFromUrl);
        if (Array.isArray(geoJson)) throw new Error('geoJson must not be an array');
        paintGeoJson(geoJson);
      };

      async function loadGeoJsonFromGist() {
        const gistIdFromUrl = new URLSearchParams(window.location.search).get('gistId');
        if(!gistIdFromUrl || gistIdFromUrl.length > 50) return;
        try {
          const response = await fetch('https://gist.githubusercontent.com/' + gistIdFromUrl + '/raw');
          const geoJson = await response.json();
          console.log('geoJson :');
          console.log(geoJson);
          paintGeoJson(geoJson);
        } catch(error) {
          console.log(error);
          return;
        }
      };

      async function loadGeoJsonFromFile(fileUrl) {
        const file = await fetch(fileUrl);
        const geoJson = await file.json();
        paintGeoJson(geoJson);
      };

      function paintGeoJson(geoJson) {
        L.geoJSON(geoJson, {
          pointToLayer: function(feature, latlng) {

            map.createPane('markerOnTop');
            map.getPane('markerOnTop').style.zIndex = 999;

            let iconPath = 'assets/icons/waypoint.png';
            if (feature.properties?.iconName) {
              iconPath = 'assets/icons/' + feature.properties.iconName + '.png';
            }
            const waypointIcon = createMapIcon(iconPath, mediumSizeIcon);

            return L.marker(
              latlng,
              { icon: waypointIcon, pane: 'markerOnTop' }
            );
          },

          style: function(feature) {
            return {
              color: feature.properties?.color || "#3388ff",
              weight: feature.properties?.weight || 3,
              opacity: feature.properties?.opacity || 1,
              fillColor: feature.properties?.fillColor || "#3388ff",
              fillOpacity: feature.properties?.fillOpacity ?? 0.2
            };
          },

          onEachFeature: function(feature, layer) {
            if (feature.properties?.popupText) {
              const popupText = feature.properties.popupText;
              let finalPopupText = '';

              if (Array.isArray(popupText)) {
                for (const line of popupText) {
                  finalPopupText += line + '<br>';
                }
              } else {
                finalPopupText = popupText;
              }
              console.log(finalPopupText)
              layer.bindPopup(finalPopupText);
            }

            if (feature.properties?.turnLayerOn) {
              if (Array.isArray(feature.properties.turnLayerOn)) {
                for (const layerName of feature.properties.turnLayerOn) {
                  const layer = allLayers[layerName];
                  if (layer) map.addLayer(layer);
                }
              } else {
                const layer = allLayers[feature.properties.turnLayerOn];
                if (layer) map.addLayer(layer);
              }
            }

            if (feature.properties?.turnLayerOff) {
              if (Array.isArray(feature.properties.turnLayerOff)) {
                for (const layerName of feature.properties.turnLayerOff) {
                  const layer = allLayers[layerName];
                  if (layer) map.removeLayer(layer);
                }
              } else {
                const layer = allLayers[feature.properties.turnLayerOff];
                if (layer) map.removeLayer(layer);
              }
            }

            if (feature.properties?.flyTo && feature.properties?.zoomTo) {
              map.flyTo(feature.properties.flyTo, feature.properties.zoomTo);
            } else if (layer?.getBounds) {
              map.fitBounds(layer.getBounds());
            }
          }
        }).addTo(waypointsLayer);

        map.addLayer(waypointsLayer);
      }

      // Default layer to show on map opening
      treesLayer.addTo(map);
      templesLayer.addTo(map);
      ruinedLayer.addTo(map);
      searchControl.addTo(map);

      L.control.layers(null, genericToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsTierToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesTierToggle, { collapsed: false }).addTo(map);

      // Load files
      loadTreesGeoJson();
      loadTemplesGeoJson();
      loadRuinedGeoJson();
      loadCavesGeoJson();
      loadClaimsGeoJson();

      // Load from gist / load from hash
      // We should validate GeoJson at this point (https://www.npmjs.com/package/@mapbox/geojsonhint ?)
      // TODO: validate iconName from predefined list
      // TODO: validate turnLayerOn and Off from predefined list

      // loadGeoJsonFromGist();
      loadGeoJsonFromHash();
    </script>
  </body>
</html>
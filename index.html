<!DOCTYPE html>
<html>
	<head>
		<title>Bitcraft Game Map</title>
    <link rel="icon" type="image/x-icon" href="assets/icons/MapCompass.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
		<link rel="stylesheet" href="assets/search/leaflet-search.src.css" crossorigin=""/>

		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js" crossorigin=""></script>
		<script src="assets/search/leaflet-search.src.js" crossorigin=""></script>

		<style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
			#map {
				height: 100vh;
				width: 100%;
        background-color: #2a3145;
			}
      #coords {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 5px 10px;
        z-index: 1000;
        font-family: monospace;
	      border-radius:.25em;
      }
    </style>
	</head>

	<body>
    <div id="map"></div>
		<div id="coords"></div>
    <script>

      // Documentation of my struggle with the map
      // When cropping the top of the image you will get a rectangle map. This is what we want but leaflet
      // Will retransform that rectangle to a square, whatever the value I put in widht and height
      // This looks bad
      // However if I load the map with the added ocean at the top, the coordinate system will be screwed
      // Conclusion, We multiply the height by the hexagon ratio to get what would be the real height with added ocean

      // The image itself is this size
			const imageWidth = 7200;
			const imageHeight = 7200;

      // Objects in Bitcraft are positionned with coordinates from 0 to 23040
      const bitcraftWidth = 23040;  
      const bitcraftHeight = 23040 * 1.1547005; // Extra ocean on top

      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -10,
        maxZoom: 10,
        zoomSnap: 0.1,
        attributionControl: false, // Remove watermark
        zoomControl: false, // Remove the zoom control top left
        preferCanvas: true,
        boxZoom: true // kinda useless (shift + drag left click mouse) might remove
      });

      // When placing a marker on the map we will use this 0-23040 system
      // The extra 1.15 we added doesnt mater, nothing will be placed there
      const mapBounds = [[0, 0], [bitcraftHeight, bitcraftWidth]];
      L.imageOverlay('assets/maps/map_final.png', mapBounds).addTo(map);

      //               N                     E
      //              lat                   lgt
      //           locationZ             locationX
      //         bottom to top         left to right
      //               v                     v
      map.setView([bitcraftHeight/2, bitcraftWidth/2], -3);

      function createMapIcon(
        iconUrl,
        iconSize = [32, 32],
        iconAnchor = [16, 16],
        popupAnchor = [0, -16]
      ) {
        return L.icon({
          iconUrl: iconUrl,
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          popupAnchor: popupAnchor,
          shadowUrl: null,
          shadowSize: null,
          shadowAnchor: null
        });
      };



      const caveIcons = [
        createMapIcon('assets/icons/FerralithOreChunk.webp'),
        createMapIcon('assets/icons/PyreliteOreChunk.webp'),
        createMapIcon('assets/icons/EmariumOreChunk.webp'),
        createMapIcon('assets/icons/ElenvarOreChunk.webp'),
        createMapIcon('assets/icons/LuminiteOreChunk.webp'),
        createMapIcon('assets/icons/RathiumOreChunk.webp'),
        createMapIcon('assets/icons/AurumiteOreChunk.webp'),
        createMapIcon('assets/icons/CelestiumOreChunk.webp'),
        createMapIcon('assets/icons/UmbraciteOreChunk.webp'),
        createMapIcon('assets/icons/AstraliteOreChunk.webp')
      ];

      const claimIcons = [
        createMapIcon('assets/icons/claim_t0.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t1.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t2.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t3.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t4.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t5.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t6.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t7.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t8.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t9.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim_t10.png', [44, 44], [22, 22], [0, -22])
      ];

      const ruinedIcon = createMapIcon('assets/icons/ruined.png',  [44, 44], [22, 22], [0, -22]);
      const templeIcon = createMapIcon('assets/icons/temple.svg');
      const treeIcon = createMapIcon('assets/icons/tree.svg');

      const treesLayer = L.layerGroup();
      const ruinedLayer = L.layerGroup();
      const templesLayer = L.layerGroup();

      const banksLayer = L.layerGroup();
      const marketsLayer = L.layerGroup();
      const waystonesLayer = L.layerGroup();

      const claimT0Layer = L.layerGroup();
      const claimT1Layer = L.layerGroup();
      const claimT2Layer = L.layerGroup();
      const claimT3Layer = L.layerGroup();
      const claimT4Layer = L.layerGroup();
      const claimT5Layer = L.layerGroup();
      const claimT6Layer = L.layerGroup();
      const claimT7Layer = L.layerGroup();
      const claimT8Layer = L.layerGroup();
      const claimT9Layer = L.layerGroup();
      const claimT10Layer = L.layerGroup();

      const claimLayers = [
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer
      ];

      const allClaims = L.layerGroup(claimLayers);

      const caveT1Layer = L.layerGroup();
      const caveT2Layer = L.layerGroup();
      const caveT3Layer = L.layerGroup();
      const caveT4Layer = L.layerGroup();
      const caveT5Layer = L.layerGroup();
      const caveT6Layer = L.layerGroup();
      const caveT7Layer = L.layerGroup();
      const caveT8Layer = L.layerGroup();
      const caveT9Layer = L.layerGroup();
      const caveT10Layer = L.layerGroup();

      const caveLayers = [
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      ];

      const allCaves = L.layerGroup(caveLayers);

      const genericToggle = {
        "Wonders": treesLayer,
        "Temples": templesLayer,
        "Ruined Cities": ruinedLayer,

        "Banks": banksLayer,
        "Markets": marketsLayer,
        "Waystones": waystonesLayer,
      };

      const claimsToggle = {
        "Claims": allClaims
      };

      const claimsTierToggle = {
        "Claims T0": claimT0Layer,
        "Claims T1": claimT1Layer,
        "Claims T2": claimT2Layer,
        "Claims T3": claimT3Layer,
        "Claims T4": claimT4Layer,
        "Claims T5": claimT5Layer,
        "Claims T6": claimT6Layer,
        "Claims T7": claimT7Layer,
        "Claims T8": claimT8Layer,
        "Claims T9": claimT9Layer,
        "Claims T10": claimT10Layer
      };

      const cavesToggle = {
        "Caves": allCaves
      };

      const cavesTierToggle = {
        "Caves T1": caveT1Layer,
        "Caves T2": caveT2Layer,
        "Caves T3": caveT3Layer,
        "Caves T4": caveT4Layer,
        "Caves T5": caveT5Layer,
        "Caves T6": caveT6Layer,
        "Caves T7": caveT7Layer,
        "Caves T8": caveT8Layer,
        "Caves T9": caveT9Layer,
        "Caves T10": caveT10Layer
      };

      treesLayer.addTo(map);
      templesLayer.addTo(map);
      ruinedLayer.addTo(map);

      L.control.layers(null, genericToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsTierToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesTierToggle, { collapsed: false }).addTo(map);

      // This is leaflet.search plugin configuration
      const controlSearch = new L.Control.Search({
        position:'topleft',		
        layer: allClaims,
        initial: false,
        marker: false,
        firstTipSubmit: true,
        zoom: 1
      });

      map.addControl(controlSearch);

      // Load the allClaims layer when we find some claim on the map
      controlSearch.on('search:locationfound', function(e) {
        if (!map.hasLayer(allClaims)) {
          map.addLayer(allClaims);
        }
      });


      async function loadTreesGeoJson() {
        const file = await fetch('assets/markers/real_trees.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {
            
            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '</br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: treeIcon }
            )
            .bindPopup(popupText)
            .addTo(treesLayer);
          }
        });
      };

      async function loadTemplesGeoJson() {
        const file = await fetch('assets/markers/real_temples.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '</br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: templeIcon }
            )
            .bindPopup(popupText)
            .addTo(templesLayer);
          }
        });
      };

      async function loadRuinedGeoJson() {
        const file = await fetch('assets/markers/real_ruined.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '</br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: ruinedIcon }
            )
            .bindPopup(popupText)
            .addTo(ruinedLayer);
          }
        });
      };

      async function loadClaimsGeoJson() {
        const file = await fetch('assets/markers/real_claims.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

          const coords = readableCoordinates(latlng);
          const name = '<a href="' + 'https://bitjita.com/claims/' + feature.properties.entityId + '" target="_blank">' + feature.properties.name + '</a>';
          const tier = ' (T' + feature.properties.tier + ')' + '</br>';
          const loc = 'N '+ coords[0] + ' E ' + coords[1] + '</br>';
          const has_bank = 'Bank : ' + (feature.properties.has_bank ? 'Yes' : 'No') + '</br>';
          const has_market = 'Market : ' + (feature.properties.has_market ? 'Yes' : 'No') + '</br>';
          const has_Waystone = 'Waystone : ' + (feature.properties.has_waystone ? 'Yes' : 'No');
          const popupText = name + tier + loc + has_bank + has_market + has_Waystone;

            const marker = L.marker(
              latlng,
              {
                title: feature.properties.name,
                icon: claimIcons[feature.properties.tier]
              }
            );

            marker.bindPopup(popupText)
            marker.addTo(claimLayers[feature.properties.tier]);

            if (feature.properties.has_bank) {
              marker.addTo(banksLayer)
            }
            if (feature.properties.has_market) {
              marker.addTo(marketsLayer)
            }
            if (feature.properties.has_waystone) {
              marker.addTo(waystonesLayer)
            }

            return marker;
          }
        });
      };

      async function loadCavesGeoJson() {
        const file = await fetch('assets/markers/real_caves.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '</br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: caveIcons[feature.properties.tier-1] }
            )
            .bindPopup(popupText)
            .addTo(caveLayers[feature.properties.tier-1]);
          }
        });
      };

      // Function to convert to N E coordinate people know about
      function readableCoordinates(latlng) {
        return [
          Math.round(latlng.lat / 23040 * 7676),
          Math.round(latlng.lng / 23040 * 7676)
        ]; 
      };
      
      // Bit of code to get the position at the mouse and display it
      // Could display biome later
      const coordDisplay = document.getElementById('coords');
      map.on('mousemove', function (e) {
        const coords = readableCoordinates(e.latlng);
        coordDisplay.innerText = 'N: ' + coords[0] + ' E: ' + coords[1];
      });

      // Load the things
      loadTreesGeoJson();
      loadTemplesGeoJson();
      loadRuinedGeoJson();
      loadCavesGeoJson();
      loadClaimsGeoJson();

    </script>
  </body>
</html>

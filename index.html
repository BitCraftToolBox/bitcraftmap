<!DOCTYPE html>
<html>
	<head>
		<title>Bitcraft Game Map</title>
    <link rel="icon" type="image/x-icon" href="assets/icons/MapCompass.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
		<link rel="stylesheet" href="assets/search/leaflet-search.src.css" crossorigin=""/>

		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js" crossorigin=""></script>
		<script src="assets/search/leaflet-search.src.js" crossorigin=""></script>

		<style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
      }
			#map {
				height: 100vh;
				width: 100%;
        background-color: #2a3145;
			}
      #coords {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: white;
        padding: 5px 10px;
        z-index: 1000;
        font-family: monospace;
	      border-radius:.25em;
      }
    </style>
	</head>

	<body>
    <div id="map"></div>
		<div id="coords"></div>
    <script>

      // Documentation of my struggle with the map
      // When cropping the top of the image you will get a rectangle map. This is what we want but leaflet
      // Will retransform that rectangle to a square, whatever the value I put in widht and height
      // This looks bad
      // However if I load the map with the added ocean at the top, the coordinate system will be screwed
      // Conclusion, We multiply the height by the hexagon ratio to get what would be the real height with added ocean

      // The image itself is this size in pixel
			const imageWidth = 7200;
			const imageHeight = 7200;

      // Objects in Bitcraft are positionned with coordinates from 0 to 23040
      const bitcraftWidth = 23040;  
      const bitcraftHeight = 23040 * 1.1547005; // Extra ocean on top

      const map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: -6,
        maxZoom: 6,
        zoomSnap: 0.1,
        attributionControl: false, // Remove watermark
        zoomControl: false, // Remove the zoom control top left
        preferCanvas: true,
        boxZoom: true // kinda useless (shift + drag left click mouse) might remove
      });

      // When placing a marker on the map we will use this 0-23040 system
      // The extra 1.15 we added doesnt mater, nothing will be placed there
      const mapBounds = [[0, 0], [bitcraftHeight, bitcraftWidth]];
      L.imageOverlay('assets/maps/map.png', mapBounds).addTo(map);

      //               N                     E
      //              lat                   lgt
      //           locationZ             locationX
      //         bottom to top         left to right
      //               v                     v
      map.setView([bitcraftHeight/2, bitcraftWidth/2], -3);

      function createMapIcon(
        iconUrl,
        iconSize = [32, 32],
        iconAnchor = [16, 16],
        popupAnchor = [0, -16]
      ) {
        return L.icon({
          iconUrl: iconUrl,
          iconSize: iconSize,
          iconAnchor: iconAnchor,
          popupAnchor: popupAnchor,
          shadowUrl: null,
          shadowSize: null,
          shadowAnchor: null
        });
      };

      const caveIcons = [
        createMapIcon('assets/icons/ore/FerralithOreChunk.png'),
        createMapIcon('assets/icons/ore/PyreliteOreChunk.png'),
        createMapIcon('assets/icons/ore/EmariumOreChunk.png'),
        createMapIcon('assets/icons/ore/ElenvarOreChunk.png'),
        createMapIcon('assets/icons/ore/LuminiteOreChunk.png'),
        createMapIcon('assets/icons/ore/RathiumOreChunk.png'),
        createMapIcon('assets/icons/ore/AurumiteOreChunk.png'),
        createMapIcon('assets/icons/ore/CelestiumOreChunk.png'),
        createMapIcon('assets/icons/ore/UmbraciteOreChunk.png'),
        createMapIcon('assets/icons/ore/AstraliteOreChunk.png')
      ];

      const claimIcons = [
        createMapIcon('assets/icons/claim/t0.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t1.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t2.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t3.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t4.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t5.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t6.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t7.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t8.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t9.png',  [44, 44], [22, 22], [0, -22]),
        createMapIcon('assets/icons/claim/t10.png', [44, 44], [22, 22], [0, -22])
      ];

      const ruinedIcon = createMapIcon('assets/icons/claim/ruined.png',  [44, 44], [22, 22], [0, -22]);
      const templeIcon = createMapIcon('assets/icons/temple.svg');
      const treeIcon = createMapIcon('assets/icons/tree.svg');

      const treesLayer = L.layerGroup();
      const ruinedLayer = L.layerGroup();
      const templesLayer = L.layerGroup();

      const banksLayer = L.layerGroup();
      const marketsLayer = L.layerGroup();
      const waystonesLayer = L.layerGroup();

      const waypointsLayer = L.layerGroup();

      const claimT0Layer = L.layerGroup();
      const claimT1Layer = L.layerGroup();
      const claimT2Layer = L.layerGroup();
      const claimT3Layer = L.layerGroup();
      const claimT4Layer = L.layerGroup();
      const claimT5Layer = L.layerGroup();
      const claimT6Layer = L.layerGroup();
      const claimT7Layer = L.layerGroup();
      const claimT8Layer = L.layerGroup();
      const claimT9Layer = L.layerGroup();
      const claimT10Layer = L.layerGroup();

      const claimLayers = [
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer
      ];

      const allClaims = L.layerGroup(claimLayers);

      const caveT1Layer = L.layerGroup();
      const caveT2Layer = L.layerGroup();
      const caveT3Layer = L.layerGroup();
      const caveT4Layer = L.layerGroup();
      const caveT5Layer = L.layerGroup();
      const caveT6Layer = L.layerGroup();
      const caveT7Layer = L.layerGroup();
      const caveT8Layer = L.layerGroup();
      const caveT9Layer = L.layerGroup();
      const caveT10Layer = L.layerGroup();

      const caveLayers = [
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      ];

      const allCaves = L.layerGroup(caveLayers);

      const genericToggle = {
        "Wonders": treesLayer,
        "Temples": templesLayer,
        "Ruined Cities": ruinedLayer,
        "Banks": banksLayer,
        "Markets": marketsLayer,
        "Waystones": waystonesLayer,
        "Waypoints": waypointsLayer,
      };

      const claimsToggle = {
        "Claims": allClaims
      };

      const claimsTierToggle = {
        "Claims T0": claimT0Layer,
        "Claims T1": claimT1Layer,
        "Claims T2": claimT2Layer,
        "Claims T3": claimT3Layer,
        "Claims T4": claimT4Layer,
        "Claims T5": claimT5Layer,
        "Claims T6": claimT6Layer,
        "Claims T7": claimT7Layer,
        "Claims T8": claimT8Layer,
        "Claims T9": claimT9Layer,
        "Claims T10": claimT10Layer
      };

      const cavesToggle = {
        "Caves": allCaves
      };

      const cavesTierToggle = {
        "Caves T1": caveT1Layer,
        "Caves T2": caveT2Layer,
        "Caves T3": caveT3Layer,
        "Caves T4": caveT4Layer,
        "Caves T5": caveT5Layer,
        "Caves T6": caveT6Layer,
        "Caves T7": caveT7Layer,
        "Caves T8": caveT8Layer,
        "Caves T9": caveT9Layer,
        "Caves T10": caveT10Layer
      };

      const allLayers = {
        treesLayer, templesLayer, ruinedLayer, banksLayer, marketsLayer, waystonesLayer, waypointsLayer,
        claimT0Layer, claimT1Layer, claimT2Layer, claimT3Layer, claimT4Layer, claimT5Layer,
        claimT6Layer, claimT7Layer, claimT8Layer, claimT9Layer, claimT10Layer,
        caveT1Layer, caveT2Layer, caveT3Layer, caveT4Layer, caveT5Layer,
        caveT6Layer, caveT7Layer, caveT8Layer, caveT9Layer, caveT10Layer
      };

      treesLayer.addTo(map);
      templesLayer.addTo(map);
      ruinedLayer.addTo(map);

      L.control.layers(null, genericToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, claimsTierToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesToggle, { collapsed: false }).addTo(map);
      L.control.layers(null, cavesTierToggle, { collapsed: false }).addTo(map);

      // This is leaflet.search plugin configuration
      // This plugin need a "title" parameter in each marker to find stuff
      const controlSearch = new L.Control.Search({
        position:'topleft',		
        layer: allClaims,
        initial: false,
        marker: false,
        firstTipSubmit: true,
        zoom: 1
      });

      map.addControl(controlSearch);

      // Load the allClaims layer when we find some claim on the map
      controlSearch.on('search:locationfound', function(marker) {
        if (!map.hasLayer(marker.layer)) {
          map.addLayer(marker.layer);
        }
      });


      async function loadTreesGeoJson() {
        const file = await fetch('assets/markers/trees.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {
            
            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: treeIcon }
            )
            .bindPopup(popupText)
            .addTo(treesLayer);
          }
        });
      };

      async function loadTemplesGeoJson() {
        const file = await fetch('assets/markers/temples.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: templeIcon }
            )
            .bindPopup(popupText)
            .addTo(templesLayer);
          }
        });
      };

      async function loadRuinedGeoJson() {
        const file = await fetch('assets/markers/ruined.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: ruinedIcon }
            )
            .bindPopup(popupText)
            .addTo(ruinedLayer);
          }
        });
      };

      async function loadClaimsGeoJson() {
        const file = await fetch('assets/markers/claims.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

          const coords = readableCoordinates(latlng);
          const name = '<a href="' + 'https://bitjita.com/claims/' + feature.properties.entityId + '" target="_blank">' + feature.properties.name + '</a>';
          const tier = ' (T' + feature.properties.tier + ')' + '<br>';
          const loc = 'N '+ coords[0] + ' E ' + coords[1] + '<br>';
          const has_bank = 'Bank : ' + (feature.properties.has_bank ? 'Yes' : 'No') + '<br>';
          const has_market = 'Market : ' + (feature.properties.has_market ? 'Yes' : 'No') + '<br>';
          const has_Waystone = 'Waystone : ' + (feature.properties.has_waystone ? 'Yes' : 'No');
          const popupText = name + tier + loc + has_bank + has_market + has_Waystone;

            const marker = L.marker(
              latlng,
              {
                title: feature.properties.name,
                icon: claimIcons[feature.properties.tier]
              }
            );

            marker.bindPopup(popupText)
            marker.addTo(claimLayers[feature.properties.tier]);

            if (feature.properties.has_bank) {
              marker.addTo(banksLayer)
            }
            if (feature.properties.has_market) {
              marker.addTo(marketsLayer)
            }
            if (feature.properties.has_waystone) {
              marker.addTo(waystonesLayer)
            }

            return marker;
          }
        });
      };

      async function loadCavesGeoJson() {
        const file = await fetch('assets/markers/caves.geojson');
        const geojsonData = await file.json();
        L.geoJSON(geojsonData, {
          pointToLayer: function(feature, latlng) {

            const coords = readableCoordinates(latlng);
            const name = feature.properties.name + '<br>';
            const loc = 'N '+ coords[0] + ' E ' + coords[1];
            const popupText = name + loc;

            return L.marker(
              latlng,
              { icon: caveIcons[feature.properties.tier-1] }
            )
            .bindPopup(popupText)
            .addTo(caveLayers[feature.properties.tier-1]);
          }
        });
      };

      // Function to convert to N E coordinate people know about
      function readableCoordinates(latlng) {
        return [
          Math.round(latlng.lat / 23040 * 7676),
          Math.round(latlng.lng / 23040 * 7676)
        ]; 
      };
      
      // Bit of code to get the position at the mouse and display it
      // Could display biome later
      // Could display ingame time, travaler task reset timer
      // Could turn on an of with an optional checkbox
      const coordDisplay = document.getElementById('coords');
      map.on('mousemove', function (e) {
        const coords = readableCoordinates(e.latlng);
        coordDisplay.innerText = 'N: ' + coords[0] + ' E: ' + coords[1];
      });

      function loadGeoJsonFromUrl() {
        try {
          const hashFromUrl =
            location.hash
            .slice(1)              // Removing the "#"
            .replace(/%20/g, ' ')  // Names can contain spaces
            .replace(/%22/g, '"')  // We need " for json
            .replace(/%7B/g, '{')  // sometimes discord remove these
            .replace(/%7D/g, '}'); // sometimes discord remove these

          // case with a # but nothing behind it
          if (!hashFromUrl) throw new Error('location.hash was empty');

          // This will validate the Json
          const geoJsonFromUrl = JSON.parse(hashFromUrl);

          // Don't give an array, you can make a feature collection instead
          if (Array.isArray(geoJsonFromUrl)) throw new Error('geoJson must not be an array');

          // We should validate GeoJson at this point (https://www.npmjs.com/package/@mapbox/geojsonhint ?)
          // And validate the values ? 
          // TODO: validate iconName from predefined list
          // TODO: validate turnLayerOn and Off from predefined list

          L.geoJSON(geoJsonFromUrl, {
            pointToLayer: function(feature, latlng) {

              map.createPane('markerOnTop');
              map.getPane('markerOnTop').style.zIndex = 999;

              let iconPath = 'assets/icons/waypoint.png';
              if (feature.properties?.iconName) {
                iconPath = 'assets/icons/' + feature.properties.iconName + '.png';
              }
              const waypointIcon = createMapIcon(iconPath, [44, 44], [22, 22], [0, -22]);

              return L.marker(
                latlng,
                { icon: waypointIcon, pane: 'markerOnTop' }
              );
            },

            style: function(feature) {
              return {
                color: feature.properties?.color || "#3388ff",
                weight: feature.properties?.weight || 3,
                opacity: feature.properties?.opacity || 1,
                fillColor: feature.properties?.fillColor || "#3388ff",
                fillOpacity: feature.properties?.fillOpacity ?? 0.2
              };
            },

            onEachFeature: function(feature, layer) {
              if (feature.properties?.popupText) {
                const popupText = feature.properties.popupText;
                let finalPopupText = '';

                if (Array.isArray(popupText)) {
                  for (const line of popupText) {
                    finalPopupText += line + '<br>';
                  }
                } else {
                  finalPopupText = popupText;
                }
                
                layer.bindPopup(finalPopupText);
              }

              if (feature.properties?.turnLayerOn) {
                if (Array.isArray(feature.properties.turnLayerOn)) {
                  for (const layerName of feature.properties.turnLayerOn) {
                    const layer = allLayers[layerName];
                    if (layer) map.addLayer(layer);
                  }
                } else {
                  const layer = allLayers[feature.properties.turnLayerOn];
                  if (layer) map.addLayer(layer);
                }
              }

              if (feature.properties?.turnLayerOff) {
                if (Array.isArray(feature.properties.turnLayerOff)) {
                  for (const layerName of feature.properties.turnLayerOff) {
                    const layer = allLayers[layerName];
                    if (layer) map.removeLayer(layer);
                  }
                } else {
                  const layer = allLayers[feature.properties.turnLayerOff];
                  if (layer) map.removeLayer(layer);
                }
              }

              if (feature.properties?.flyTo && feature.properties?.zoomTo) {
                map.flyTo(feature.properties.flyTo, feature.properties.zoomTo);
              } else if (layer?.getBounds) {
                map.fitBounds(layer.getBounds());
              }
            }
          }).addTo(waypointsLayer);

          map.addLayer(waypointsLayer);
        } catch (error) {
          console.log(error);
          return;
        } 
      };

      
      // Load the things
      loadTreesGeoJson();
      loadTemplesGeoJson();
      loadRuinedGeoJson();
      loadCavesGeoJson();
      loadClaimsGeoJson();
      loadGeoJsonFromUrl();
    </script>
  </body>
</html>